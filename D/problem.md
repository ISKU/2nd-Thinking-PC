### 제목
CPU

### 문제
<p>디지털하드웨어설계 과목의 최종 프로젝트는 16-bit CPU를 설계하고 Verilog 언어로 구현하는 것이다. 본인이 구현한 CPU가 제대로 동작하는지 테스트하기 위해서는 기계어 코드를 입력으로 주어야 한다. 하지만 대부분의 사람은 0과 1로만 이루어진 기계어 코드를 이해하기 힘들어서 C++, Java와 같은 프로그래밍 언어로 코드를 작성하고 컴파일러를 통해 기계어 코드로 번역하는 과정을 거친다.</p>

<p>여러 가지 프로그래밍 언어 중에서 어셈블리어는 사람이 이해하기 쉬우면서 기계어와 가장 유사한 언어이다. 어셈블리어 코드는 어셈블러를 통해 기계어 코드로 번역된다. 그리고 어셈블리어는 기계어와 일대일로 대응하는 특징이 있다. 예를 들면, 두 수의 합을 구하는 연산의 어셈블리어 코드가 <code>ADD</code>이고, 기계어 코드가 <code>00000</code>이면 어셈블러는 <code>ADD</code>를 읽어서 그대로 <code>00000</code>로 바꾸어주는 것이다.</p>

<p>아래의 그림은 민호가 설계한 CPU가 처리할 수 있는 16-bit 단위 명령어들의 구조를 모아놓은 표이다.</p>

![Alt Text](https://github.com/ISKU/2nd-Thinking-PC/blob/master/D/img/IMG_01.png)

<p>입력과 출력은 항상 명령어 단위이며, 어셈블리어 코드는 <em>&quot;opcode rD rA rB&quot;</em> 또는 <em>&quot;opcode rD rA #C&quot;</em>의 형태이다. 기본적으로 레지스터 <em>rA</em>와 <em>rB</em>에 있는 두 수 또는 레지스터 <em>rA</em>에 있는 수와 상수 <em>#C</em>를 <em>opcode</em>에 해당하는 연산을 수행하고, 그 결괏값을 레지스터 <em>rD</em>에 저장하는 명령어이다. <em>rA</em>는 <em>opcode</em>에 따라 사용하지 않을 수도 있다. 어셈블러는 <em>opcode, rD, rA, rB, #C</em>를 각 bit의 자리에 맞게 2진수 0과 1로 이루어진 16-bit 기계어 코드로 변역한다. bit마다 자리의 의미는 아래와 같다.</p>

<ul>
	<li>0~4 : CPU가 수행해야 할 연산을 나타내는 <em>opcode</em>이다. 만약 4번 bit가 <code>0</code>일 경우 레지스터 <em>rB</em>를, <code>1</code>일 경우 상수 <em>#C</em>를 사용한다.</li>
	<li>5 : 사용하지 않는 bit이며, 항상 <code>0</code>이다.</li>
	<li>6~8 : 결괏값을 저장하는 레지스터 <em>rD</em>의 번호이다.</li>
	<li>9~11 : 연산에 사용되는 레지스터 <em>rA</em>의 번호이다. 사용하지 않을 경우 <code>000</code>이다.</li>
	<li>12~15 : 만약 4번 bit가 <code>0</code>일 경우 12~14번 bit는 연산에 사용되는 레지스터 <em>rB</em>의 번호이며, 15번 bit는 항상 <code>0</code>이다. 만약 4번 bit가 <code>1</code>일 경우 12~15번 bit는 상수 <em>#C</em>이다.</li>
</ul>

<p>디지털하드웨어설계 과목을 듣는 민호는 Verilog로 16-bit CPU 구현을 일찍 끝내 놓은 상태이다. 이 16-bit CPU를 테스트하기 위해서는 기계어를 매번 입력으로 줘야 하는데, 너무나 귀찮은 민호는 이에 맞는 어셈블러를 구현하려고 한다. 민호가 직접 설계한 16-bit CPU의 명령어 구조 표를 보고, 어셈블리어 코드가 주어졌을 때 이를 기계어 코드로 번역하는 어셈블러를 만들어보자.</p>

### 입력
<p>첫 번째 줄에는 명령어의 개수를 의미하는 정수 <em>N</em> (1 &le; <em>N</em> &le; 500)이 주어진다.</p>

<p>다음 <em>N</em>개의 각 줄에는 명령어가 어셈블리어 코드로 <em>&quot;opcode rD rA rB&quot;</em> 또는 <em>&quot;opcode rD rA #C&quot;</em>의 형태로 주어진다. 문자열 <em>opcode</em>는 항상 대문자이다. 정수 <em>rD, rA, rB</em> (0 &le; <em>rD, rA, rB</em> &le; 7)는 레지스터 번호를 의미한다. 만약 사용되지 않는 경우에 0이 주어진다. 정수 <em>#C</em> (0 &le; <em>#C</em> &le; 15)는 상수를 의미한다.</p>

<p>기계어 코드로 번역될 때, 어긋나는 입력은 주어지지 않는다.</p>

### 출력
<p><em>N</em>개의 각 줄에 어셈블리어 코드를 기계어 코드로 번역하여 출력한다.</p>

### 예제 입력 1
```
4
MOVC 1 0 5
MOVC 2 0 10
ADD 3 1 2
SUB 4 1 2
```

### 예제 출력 1
```
0010100010000101
0010100100001010
0000000110010100
0001001000010100
```

### 예제 입력 2
```
8
LSFTL 4 2 4
MULTC 3 7 12
NOT 2 0 4
SUB 4 4 3
ASFTR 6 4 1
MULT 7 7 5
RLC 6 4 14
RR 1 5 4
```

### 예제 출력 2
```
0111001000101000
0110100111111100
0101000100001000
0001001001000110
1001001101000010
0110001111111010
1010101101001110
1011000011011000
```

### 분류
구현
